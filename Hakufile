import "tasks/env_check.haku"

BUILDER_NAME = 'arena-autocam_builder'

package_home = `readlink --canonicalize .`
cargo_target_dir = join($package_home, "target")
gst_plugins_so_filename = 'libgst_tflite_plugins.so'

# Ensure that we keep those logs fat
set-env("RUST_BACKTRACE", "full")
if ! ${CARGO_LOG}:
  set-env("CARGO_LOG", "cargo::core::compiler::fingerprint=info")
end

# Docker globals
docker_cmd_with_opts = "docker --log-level=info"
docker_repo = "ubuntu-desktop.local:5000"
set-env("BUILDKIT_PROGRESS", "plain")

# Computed by _setup_target_docker_compose_string
target_docker_compose_string = "NOT SET"

# Computes the contents of the build target's docker-compose.yaml, escapes its
# newlines, and assigns it to the `target_docker_compose_string` global variable
_setup_target_docker_compose_string:
  compose_file_args = "--file docker/docker-compose.yaml"
  if ${target} == ${AARCH64_TARGET_TRIPLE}:
    # Use cross to build the ARM target in a Docker container.
    build_cmd = "cross"
    compose_file_args = "${compose_file_args} --file docker/docker-compose.aarch64.yaml"
  else
    # If we're X86_64, use regular old Cargo
    build_cmd = "cargo"
    compose_file_args = "${compose_file_args} --file docker/docker-compose.amd64.yaml"
  end

  convert_result = `FROM_HAKU=1 ${docker_cmd_with_opts} compose ${compose_file_args} convert`
  if ! ${convert_result}:
    error 'Failed to merge docker-compose files'
  else:
    println($convert_result)
  end
  convert_result = replace(${convert_result}, "\n", '\\n')
  # Set the global variable
  target_docker_compose_string = ${convert_result}

## Builds the app using the provided `PROFILE` and `TARGET` environment variables
build: prepare_env setup_target_docker_compose_string
  if ${target} == ${AARCH64_TARGET_TRIPLE}:
    bazel_cache_host_path = "target/${TARGET}/${AA_BUILD_PROFILE}/aa_bazel_cache"
    mkdir -p ${bazel_cache_host_path}

    # Use cross to build the ARM target in a Docker container.
    build_cmd = "AA_BAZEL_CACHE='${bazel_cache_host_path}' CROSS_RUNNER='' cross"
  else
    # If we're X86_64, use regular old Cargo
    build_cmd = "cargo"
  end

  # Now we should have all the build arifacts sitting in target/{target}/{profile}
  ${build_cmd} -vvv build \
      --workspace --target ${target} \
      --profile ${profile}

  # DOCKER
  # Create a new set of images from the merged docker-compose
  bake_cmd = "echo '${target_docker_compose_string}' | \
      ${docker_cmd_with_opts} buildx bake --progress=plain --load --file -"
  ${bake_cmd}

  # Push the images to our private repo (its address is stored in the
  # .env file)
  push_cmd = "echo '${target_docker_compose_string}' | \
      ${docker_cmd_with_opts} compose --file - push"
  ${push_cmd}

run: setup_target_docker_compose_string
    docker_context_arg = ""
    if ${target} == ${AARCH64_TARGET_TRIPLE}:
      docker_context_arg = "--context=pi-horsie"
    end

    up_cmd = "echo '${target_docker_compose_string}' | \
        ${docker_cmd_with_opts} ${docker_context_arg} compose --file - up \
        --pull always --no-build"
    ${up_cmd}

build_example example_name: prepare_env create_builder
  image_name = "${docker_repo}/arena-autocam/pre_build_io_${TARGETARCH_DOCKER}"
  tagged_image_name = "${image_name}:latest"
  build_cache_image_name = "${image_name}:build-cache"

  println("Building ${tagged_image_name}")

  ${docker_cmd_with_opts} buildx build \
    --builder=${BUILDER_NAME} \
    --pull \
    --cache-from=type=registry,ref=${build_cache_image_name} \
    --cache-to=type=registry,ref=${build_cache_image_name},mode=max \
    --allow=network.host,security.insecure \
    --network=host \
    --progress=plain \
    --file=docker/pre-build-io.dockerfile \
    --build-arg DOCKER_REPO=${docker_repo} \
    --build-arg TARGETARCH_DOCKER=${TARGETARCH_DOCKER} \
    --tag=${tagged_image_name} \
    --output type=image,push=true \
    ${package_home}/

  image_name = "${docker_repo}/arena-autocam/${example_name}_example_build_${TARGETARCH_DOCKER}"
  tagged_image_name = "${image_name}:latest"
  build_cache_image_name = "${image_name}:build-cache"

  println("Building ${tagged_image_name}")

  ${docker_cmd_with_opts} buildx build \
    --builder=${BUILDER_NAME} \
    --pull \
    --cache-from=type=registry,ref=${build_cache_image_name} \
    --cache-to=type=registry,ref=${build_cache_image_name},mode=max \
    --allow=network.host,security.insecure \
    --network=host \
    --progress=plain \
    --file=docker/build-single-target.dockerfile \
    --build-arg DOCKER_REPO=${docker_repo} \
    --build-arg RUST_BUILD_TARGET='--example ${example_name}' \
    --build-arg RUST_PROFILE=${PROFILE} \
    --build-arg RUST_TARGET=${TARGET} \
    --build-arg TARGETARCH_DOCKER=${TARGETARCH_DOCKER} \
    --tag=${tagged_image_name} \
    --output type=image,push=true \
    ${package_home}/


## Builds the Docker images used to build the application
build_platform_builder_bases: create_builder
  image_base_name = "${docker_repo}/arena-autocam/builder_base"

  # Build the base build image
  image_name = "${image_base_name}"
  tagged_image_name = "${image_name}:latest"
  build_cache_image_name = "${image_name}:build-cache"
  ${docker_cmd_with_opts} buildx build \
    --builder=${BUILDER_NAME} \
    --cache-from=type=registry,ref=${build_cache_image_name} \
    --cache-to=type=registry,ref=${build_cache_image_name},mode=max \
    --allow=network.host,security.insecure \
    --network=host \
    --progress=plain \
    --file=docker/builder-base.dockerfile \
    --build-arg DOCKER_REPO=${docker_repo} \
    --tag=${tagged_image_name} \
    --output type=image,push=true \
    ${package_home}/docker

  # Build the arch-specific build bases
  for platform in ${DOCKER_PLATFORMS}:
    os = field-sep($platform, "/", 0)
    arch = field-sep($platform, "/", 1)
    image_name = "${image_base_name}_${arch}"
    tagged_image_name = "${image_name}:latest"
    build_cache_image_name = "${image_name}:build-cache"

    # Build the platform image
    ${docker_cmd_with_opts} buildx build \
      --builder=${BUILDER_NAME} \
      --pull \
      --cache-from=type=registry,ref=${build_cache_image_name} \
      --cache-to=type=registry,ref=${build_cache_image_name},mode=max \
      --allow=network.host,security.insecure \
      --network=host \
      --progress=plain \
      --file=docker/builder-base.${arch}.dockerfile \
      --build-arg DOCKER_REPO=${docker_repo} \
      --platform=${platform} \
      --tag=${tagged_image_name} \
      --output type=image,push=true \
      ${package_home}/docker
  end

## Creates a buildx builder instance, if necessary
create_builder:
  # The caller can force the creation of a builder (which we implement by
  # destroying it first)
  if is_set('create_builder_force'):
    @docker buildx rm ${BUILDER_NAME}
  end

  has_builder = `docker buildx use ${BUILDER_NAME}`
  if !${has_builder}:
    # Build a builder with local platforms
    docker buildx create --driver=docker-container \
        --name=${BUILDER_NAME} \
        --config ${package_home}/docker/config/buildkitd.toml \
        --driver-opt=network=host \
        --bootstrap --use \
        --buildkitd-flags '--allow-insecure-entitlement security.insecure' \
        ${invoke-dir()}
  end

clean:
  cargo clean
